---
title: 操作系统信号量
description: signal
date: 2023-10-30
weight: 10000


---
<style>
th, td {
  border: 1px solid rgb(190, 190, 190);
}
</style>

### 查看当前core的大小限制
```bash
[root@node85 ~]# ulimit -a|grep core
core file size          (blocks, -c) unlimited

```




#### signal 11
> `SIGSEGV`


###### 原因
造成Fatal signal 11的主要原因是程序试图访问一块无效的内存地址。这可以是由以下几种情况引起的：

1. 野指针（Null pointer）：当你将一个空指针作为变量访问时，就会发生段错误。
2. 释放已释放的内存：如果你释放了一块内存，然后尝试再次访问它，也会导致段错误。
3. 数组越界访问：当你访问数组超出其范围时，也会发生段错误。
4. 对只读内存的写操作：如果程序试图写入只读内存，也会引发段错误。 这些都是常见的情况，但还有其他一些可能导致段错误的情况，如指针操作错误、栈溢出等。


- 空指针异常
```c++
#include <iostream>
int main() {
    int* ptr = nullptr;
    *ptr = 10; // 试图访问空指针的内存地址
    return 0;
}

```

```bash
g++ -g  a.cc

./a.out

gdb ./a.out   core-file
```

###### 解决

一旦遇到Fatal signal 11错误，我们需要进行调试以找到导致错误的原因。以下是一些常见的调试方法：

1. 使用调试器：使用调试器（如gdb）可以帮助定位错误发生的位置。你可以设置断点、逐步执行程序并观察变量的值，以找到错误的根本原因。
2. 打印调试信息：在程序中插入打印语句，输出各个关键点的变量值，以帮助你追踪代码执行路径并找到错误位置。
3. 检查内存访问：检查程序中的指针操作和内存访问，确保没有访问无效的内存地址或数组越界访问。
4. 检查释放内存的正确性：确保释放内存的操作正确，不会导致后续访问已释放的内存。
5. 防御性编程：在编写代码时，采取一些防御性编程的措施，如空指针检查、数组范围检查等，以避免潜在的错误。 解决Fatal signal 11错误的过程可能会比较复杂，因为它可能涉及到代码的不同部分和多个调试步骤。然而，通过耐心地调试和检查代码，你应该能够找到并解决这类错误。





















