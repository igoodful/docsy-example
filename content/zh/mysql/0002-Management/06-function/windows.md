---
title: 窗口函数
description: windows
date: 2024-10-11
weight: 20000
---

{{<note>}}
<!---->






{{</note>}}



## 简介


**语法**：

```sql
 over (
    [partition by <分区表达式>]
    [order by <排序表达式> [asc | desc]]
    [rows/range <窗口范围>]
)
```
- `<窗口函数>(<参数>)` ：指定要使用的窗口函数及其参数，窗口函数可以是聚合函数，也可以是专门为窗口函数设计的函数
- `over()` ：定义窗口的框架
- [partition by <分区表达式>] ：将结果集分成多个分区，窗口函数会在每个分区内独立执行。分区表达式可以是一个或多个列名，用于确定如何将结果集分成不同的分区
- [order by <排序表达式> [asc | desc]] ：指定窗口内行的排序顺序
- [rows/range <窗口范围>]：定义窗口的行范围
  - rows `frame_specification` 基于行的物理位置来确定窗口范围
  - range `frame_specification` 基于order by子句中指定的列值来确定窗口范围


**frame_specification**

- between frame_start and frame_end ：指定窗口的开始和结束边界。
- frame_start ：如果只指定了开始边界，则窗口会从该边界延伸到当前分区的最后一行。
- frame_end ：通常不会只单独指定结束边界，因为它需要开始边界来形成完整的窗口范围。

frame_start和frame_end可以是以下值之一：
- unbounded preceding：窗口从当前分区的第一行开始。
- n preceding：窗口从当前行之前的第n行开始，n是一个正整数。
- current row：窗口从当前行开始。
- n following：窗口从当前行之后的第n行开始。
- unbounded following：窗口到当前分区的最后一行结束（通常只用于frame_end）。


```sql
[root@127.0.0.1:8032 15:33:25(mysql)]$ select ht.name,ht.help_topic_id,ht.help_category_id from mysql.help_topic ht where ht.help_category_id=(select hc.help_category_id from mysql.help_category hc where hc.name='Window Functions');
+--------------+---------------+------------------+
| name         | help_topic_id | help_category_id |
+--------------+---------------+------------------+
| CUME_DIST    |           437 |               36 |
| DENSE_RANK   |           438 |               36 |
| FIRST_VALUE  |           439 |               36 |
| LAG          |           440 |               36 |
| LAST_VALUE   |           441 |               36 |
| LEAD         |           442 |               36 |
| NTH_VALUE    |           443 |               36 |
| NTILE        |           444 |               36 |
| PERCENT_RANK |           445 |               36 |
| RANK         |           446 |               36 |
| ROW_NUMBER   |           447 |               36 |
+--------------+---------------+------------------+
11 rows in set (0.00 sec)

```


语法

```sql
<窗口函数>(<参数>) OVER (
    [PARTITION BY <分区表达式>]
    [ORDER BY <排序表达式> [ASC | DESC]]
    [ROWS/Range <窗口范围>]
)
```




## 准备数据

```sql
create database db1;

create table employee (
  id bigint unsigned not null auto_increment,
  dname varchar(20) default null,
  eid varchar(20) default null,
  ename varchar(20) default null,
  hiredate date default null,
  salary double default null,
  primary key (id)
) engine=innodb default charset=utf8mb4 collate=utf8mb4_bin;

insert into employee values(null,'研发部','1001','刘备','2021-11-01',3000);
insert into employee values(null,'研发部','1002','关羽','2021-11-02',5000);
insert into employee values(null,'研发部','1003','张飞','2021-11-03',7000);
insert into employee values(null,'研发部','1004','赵云','2021-11-04',7000);
insert into employee values(null,'研发部','1005','马超','2021-11-05',4000);
insert into employee values(null,'研发部','1006','黄忠','2021-11-06',4000);
insert into employee values(null,'销售部','1007','曹操','2021-11-01',2000);
insert into employee values(null,'销售部','1008','许褚','2021-11-02',3000);
insert into employee values(null,'销售部','1009','典韦','2021-11-03',5000);
insert into employee values(null,'销售部','1010','张辽','2021-11-04',6000);
insert into employee values(null,'销售部','1011','徐晃','2021-11-05',9000);
insert into employee values(null,'销售部','1012','曹洪','2021-11-06',6000);

```

数据如下：

```sql
[root@127.0.0.1:8032 16:04:17(db1)]$ select * from employee;
+----+-----------+------+--------+------------+--------+
| id | dname     | eid  | ename  | hiredate   | salary |
+----+-----------+------+--------+------------+--------+
|  1 | 研发部    | 1001 | 刘备   | 2021-11-01 |   3000 |
|  3 | 研发部    | 1002 | 关羽   | 2021-11-02 |   5000 |
|  5 | 研发部    | 1003 | 张飞   | 2021-11-03 |   7000 |
|  7 | 研发部    | 1004 | 赵云   | 2021-11-04 |   7000 |
|  9 | 研发部    | 1005 | 马超   | 2021-11-05 |   4000 |
| 11 | 研发部    | 1006 | 黄忠   | 2021-11-06 |   4000 |
| 13 | 销售部    | 1007 | 曹操   | 2021-11-01 |   2000 |
| 15 | 销售部    | 1008 | 许褚   | 2021-11-02 |   3000 |
| 17 | 销售部    | 1009 | 典韦   | 2021-11-03 |   5000 |
| 19 | 销售部    | 1010 | 张辽   | 2021-11-04 |   6000 |
| 21 | 销售部    | 1011 | 徐晃   | 2021-11-05 |   9000 |
| 23 | 销售部    | 1012 | 曹洪   | 2021-11-06 |   6000 |
+----+-----------+------+--------+------------+--------+
12 rows in set (0.00 sec)


```




## 非聚合类窗口函数



### 1. row_number
> 每一行分配一个唯一的自增序号

 **语法**

```sql
row_number() over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

```sql
select dname,ename,salary,
row_number() over (partition by dname order by salary desc ) as `row_number`,
rank() over (partition by dname order by salary desc ) as `rank`,
dense_rank() over (partition by dname order by salary desc ) as `dense_rank` from employee;

```



### 2. rank
> 为每一行分配一个排名，对于相同的值会留下空位

 **语法**

```sql
rank() over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

```sql
select dname,ename,salary,
row_number() over (partition by dname order by salary desc ) as `row_number`,
rank() over (partition by dname order by salary desc ) as `rank`,
dense_rank() over (partition by dname order by salary desc ) as `dense_rank` from employee;

```



### 3. dense_rank
> 为每一行分配一个排名，但不会为相同的值留下空位

 **语法**

```sql
dense_rank() over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

```sql
[root@127.0.0.1:8032 17:22:59(db1)]$ select dname,ename,salary from employee;
+-----------+--------+--------+
| dname     | ename  | salary |
+-----------+--------+--------+
| 研发部    | 刘备   |   3000 |
| 研发部    | 关羽   |   5000 |
| 研发部    | 张飞   |   7000 |
| 研发部    | 赵云   |   7000 |
| 研发部    | 马超   |   4000 |
| 研发部    | 黄忠   |   4000 |
| 销售部    | 曹操   |   2000 |
| 销售部    | 许褚   |   3000 |
| 销售部    | 典韦   |   5000 |
| 销售部    | 张辽   |   6000 |
| 销售部    | 徐晃   |   9000 |
| 销售部    | 曹洪   |   6000 |
+-----------+--------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 17:23:11(db1)]$ select dname,ename,salary,row_number() over (partition by dname order by salary desc ) as `row_number`,rank() over (partition by dname order by salary desc ) as `rank`,dense_rank() over (partition by dname order by salary desc ) as `dense_rank` from employee;
+-----------+--------+--------+------------+------+------------+
| dname     | ename  | salary | row_number | rank | dense_rank |
+-----------+--------+--------+------------+------+------------+
| 研发部    | 张飞   |   7000 |          1 |    1 |          1 |
| 研发部    | 赵云   |   7000 |          2 |    1 |          1 |
| 研发部    | 关羽   |   5000 |          3 |    3 |          2 |
| 研发部    | 马超   |   4000 |          4 |    4 |          3 |
| 研发部    | 黄忠   |   4000 |          5 |    4 |          3 |
| 研发部    | 刘备   |   3000 |          6 |    6 |          4 |
| 销售部    | 徐晃   |   9000 |          1 |    1 |          1 |
| 销售部    | 张辽   |   6000 |          2 |    2 |          2 |
| 销售部    | 曹洪   |   6000 |          3 |    2 |          2 |
| 销售部    | 典韦   |   5000 |          4 |    4 |          3 |
| 销售部    | 许褚   |   3000 |          5 |    5 |          4 |
| 销售部    | 曹操   |   2000 |          6 |    6 |          5 |
+-----------+--------+--------+------------+------+------------+
12 rows in set (0.00 sec)


```


### 4. percent_rank

 **语法**

```sql
percent_rank(expression) over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**


### 5. cume_dist
> 分布函数


 **语法**

```sql
cume_dist(expression) over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

分组内小于、等于当前rank值的行数 / 分组内总行数

需求：查询小于等于当前薪资（salary）的比例

```sql
[root@127.0.0.1:8032 16:20:31(db1)]$ select dname,ename,salary from employee;
+-----------+--------+--------+
| dname     | ename  | salary |
+-----------+--------+--------+
| 研发部    | 刘备   |   3000 |
| 研发部    | 关羽   |   5000 |
| 研发部    | 张飞   |   7000 |
| 研发部    | 赵云   |   7000 |
| 研发部    | 马超   |   4000 |
| 研发部    | 黄忠   |   4000 |
| 销售部    | 曹操   |   2000 |
| 销售部    | 许褚   |   3000 |
| 销售部    | 典韦   |   5000 |
| 销售部    | 张辽   |   6000 |
| 销售部    | 徐晃   |   9000 |
| 销售部    | 曹洪   |   6000 |
+-----------+--------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 16:20:36(db1)]$ select dname, ename, salary, rank() over(partition by dname order by salary desc ) as rn, cume_dist() over(partition by dname order by salary desc ) as cd from employee;
+-----------+--------+--------+----+---------------------+
| dname     | ename  | salary | rn | cd                  |
+-----------+--------+--------+----+---------------------+
| 研发部    | 张飞   |   7000 |  1 |  0.3333333333333333 |
| 研发部    | 赵云   |   7000 |  1 |  0.3333333333333333 |
| 研发部    | 关羽   |   5000 |  3 |                 0.5 |
| 研发部    | 马超   |   4000 |  4 |  0.8333333333333334 |
| 研发部    | 黄忠   |   4000 |  4 |  0.8333333333333334 |
| 研发部    | 刘备   |   3000 |  6 |                   1 |
| 销售部    | 徐晃   |   9000 |  1 | 0.16666666666666666 |
| 销售部    | 张辽   |   6000 |  2 |                 0.5 |
| 销售部    | 曹洪   |   6000 |  2 |                 0.5 |
| 销售部    | 典韦   |   5000 |  4 |  0.6666666666666666 |
| 销售部    | 许褚   |   3000 |  5 |  0.8333333333333334 |
| 销售部    | 曹操   |   2000 |  6 |                   1 |
+-----------+--------+--------+----+---------------------+
12 rows in set (0.00 sec)

```


### 6. lag
> 返回位于当前行的前n行（LAG(expr,n)）的expr的值

 **语法**

```sql
lag(<expression>[,offset[, default_value]]) over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

需求：查询前1名同学的成绩和当前同学成绩的差值

```sql
[root@127.0.0.1:8032 16:23:01(db1)]$ select dname,ename,hiredate,salary from employee;
+-----------+--------+------------+--------+
| dname     | ename  | hiredate   | salary |
+-----------+--------+------------+--------+
| 研发部    | 刘备   | 2021-11-01 |   3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 |
| 研发部    | 马超   | 2021-11-05 |   4000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 |
+-----------+--------+------------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 16:23:35(db1)]$ select dname, ename, hiredate, salary, lag(hiredate,1,'2000-01-01') over(partition by dname order by hiredate) as last_1_time, lag(hiredate,2) over(partition by dname order by hiredate) as last_2_time from employee;
+-----------+--------+------------+--------+-------------+-------------+
| dname     | ename  | hiredate   | salary | last_1_time | last_2_time |
+-----------+--------+------------+--------+-------------+-------------+
| 研发部    | 刘备   | 2021-11-01 |   3000 | 2000-01-01  | NULL        |
| 研发部    | 关羽   | 2021-11-02 |   5000 | 2021-11-01  | NULL        |
| 研发部    | 张飞   | 2021-11-03 |   7000 | 2021-11-02  | 2021-11-01  |
| 研发部    | 赵云   | 2021-11-04 |   7000 | 2021-11-03  | 2021-11-02  |
| 研发部    | 马超   | 2021-11-05 |   4000 | 2021-11-04  | 2021-11-03  |
| 研发部    | 黄忠   | 2021-11-06 |   4000 | 2021-11-05  | 2021-11-04  |
| 销售部    | 曹操   | 2021-11-01 |   2000 | 2000-01-01  | NULL        |
| 销售部    | 许褚   | 2021-11-02 |   3000 | 2021-11-01  | NULL        |
| 销售部    | 典韦   | 2021-11-03 |   5000 | 2021-11-02  | 2021-11-01  |
| 销售部    | 张辽   | 2021-11-04 |   6000 | 2021-11-03  | 2021-11-02  |
| 销售部    | 徐晃   | 2021-11-05 |   9000 | 2021-11-04  | 2021-11-03  |
| 销售部    | 曹洪   | 2021-11-06 |   6000 | 2021-11-05  | 2021-11-04  |
+-----------+--------+------------+--------+-------------+-------------+
12 rows in set (0.00 sec)


```

### 7. lead

返回位于当前行的后n行（LEAD(expr,n)）的expr的值

需求：查询前1名同学的成绩和当前同学成绩的差值


### 8. first_value

> 返回位于当前行的前n行（LAG(expr,n)）的expr的值

 **语法**

```sql
first_value(expression) over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

```sql
[root@127.0.0.1:8032 16:33:31(db1)]$ select dname, ename, hiredate, salary from  employee;
+-----------+--------+------------+--------+
| dname     | ename  | hiredate   | salary |
+-----------+--------+------------+--------+
| 研发部    | 刘备   | 2021-11-01 |   3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 |
| 研发部    | 马超   | 2021-11-05 |   4000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 |
+-----------+--------+------------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 16:34:03(db1)]$ select dname, ename, hiredate, salary, first_value(salary) over(partition by dname order by hiredate) as first from  employee;
+-----------+--------+------------+--------+-------+
| dname     | ename  | hiredate   | salary | first |
+-----------+--------+------------+--------+-------+
| 研发部    | 刘备   | 2021-11-01 |   3000 |  3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 |  3000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 |  3000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 |  3000 |
| 研发部    | 马超   | 2021-11-05 |   4000 |  3000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 |  3000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 |  2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 |  2000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 |  2000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 |  2000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 |  2000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 |  2000 |
+-----------+--------+------------+--------+-------+
12 rows in set (0.00 sec)

```


### 9. last_value
> last_value()函数用于返回当前最后一个值


 **语法**

```sql
last_value(expression) over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

```sql
[root@127.0.0.1:8032 16:58:08(db1)]$ select dname, ename, hiredate, salary from  employee;
+-----------+--------+------------+--------+
| dname     | ename  | hiredate   | salary |
+-----------+--------+------------+--------+
| 研发部    | 刘备   | 2021-11-01 |   3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 |
| 研发部    | 马超   | 2021-11-05 |   4000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 |
+-----------+--------+------------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 16:58:12(db1)]$ select dname, ename, hiredate, salary, last_value(salary) over(partition by dname order by hiredate) as last from  employee;
+-----------+--------+------------+--------+------+
| dname     | ename  | hiredate   | salary | last |
+-----------+--------+------------+--------+------+
| 研发部    | 刘备   | 2021-11-01 |   3000 | 3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 | 5000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 | 7000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 | 7000 |
| 研发部    | 马超   | 2021-11-05 |   4000 | 4000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 | 4000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 | 2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 | 3000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 | 5000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 | 6000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 | 9000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 | 6000 |
+-----------+--------+------------+--------+------+
12 rows in set (0.00 sec)

```


### 10. nth_value
> nth_value()函数用于返回有序行的第n小的值


 **语法**

```sql
nth_value(expression) over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

```sql
[root@127.0.0.1:8032 17:04:10(db1)]$ select dname, ename, hiredate, salary from employee;
+-----------+--------+------------+--------+
| dname     | ename  | hiredate   | salary |
+-----------+--------+------------+--------+
| 研发部    | 刘备   | 2021-11-01 |   3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 |
| 研发部    | 马超   | 2021-11-05 |   4000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 |
+-----------+--------+------------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 17:04:21(db1)]$ select dname, ename, hiredate, salary, nth_value(salary,1) over(partition by dname order by hiredate  ) as nth from  employee;
+-----------+--------+------------+--------+------+
| dname     | ename  | hiredate   | salary | nth  |
+-----------+--------+------------+--------+------+
| 研发部    | 刘备   | 2021-11-01 |   3000 | 3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 | 3000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 | 3000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 | 3000 |
| 研发部    | 马超   | 2021-11-05 |   4000 | 3000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 | 3000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 | 2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 | 2000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 | 2000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 | 2000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 | 2000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 | 2000 |
+-----------+--------+------------+--------+------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 17:04:26(db1)]$ select dname, ename, hiredate, salary, nth_value(salary,2) over(partition by dname order by hiredate  ) as nth from  employee;
+-----------+--------+------------+--------+------+
| dname     | ename  | hiredate   | salary | nth  |
+-----------+--------+------------+--------+------+
| 研发部    | 刘备   | 2021-11-01 |   3000 | NULL |
| 研发部    | 关羽   | 2021-11-02 |   5000 | 5000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 | 5000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 | 5000 |
| 研发部    | 马超   | 2021-11-05 |   4000 | 5000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 | 5000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 | NULL |
| 销售部    | 许褚   | 2021-11-02 |   3000 | 3000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 | 3000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 | 3000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 | 3000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 | 3000 |
+-----------+--------+------------+--------+------+
12 rows in set (0.00 sec)

```

### 11. ntile
> 将分区中的有序数据分为n个等级，记录等级数

 **语法**

```sql
ntile(expression) over (
    partition by expr,...
    order by expr [asc|desc],...
)
```


 **示例**

需求：将每个部门员工按照入职日期分成3组

```sql
[root@127.0.0.1:8032 17:07:20(db1)]$ select dname, ename, hiredate, salary from employee;
+-----------+--------+------------+--------+
| dname     | ename  | hiredate   | salary |
+-----------+--------+------------+--------+
| 研发部    | 刘备   | 2021-11-01 |   3000 |
| 研发部    | 关羽   | 2021-11-02 |   5000 |
| 研发部    | 张飞   | 2021-11-03 |   7000 |
| 研发部    | 赵云   | 2021-11-04 |   7000 |
| 研发部    | 马超   | 2021-11-05 |   4000 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 |
| 销售部    | 曹操   | 2021-11-01 |   2000 |
| 销售部    | 许褚   | 2021-11-02 |   3000 |
| 销售部    | 典韦   | 2021-11-03 |   5000 |
| 销售部    | 张辽   | 2021-11-04 |   6000 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 |
+-----------+--------+------------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 17:07:29(db1)]$ select dname, ename, hiredate, salary, ntile(3) over(partition by dname order by hiredate ) as nt from employee;
+-----------+--------+------------+--------+----+
| dname     | ename  | hiredate   | salary | nt |
+-----------+--------+------------+--------+----+
| 研发部    | 刘备   | 2021-11-01 |   3000 |  1 |
| 研发部    | 关羽   | 2021-11-02 |   5000 |  1 |
| 研发部    | 张飞   | 2021-11-03 |   7000 |  2 |
| 研发部    | 赵云   | 2021-11-04 |   7000 |  2 |
| 研发部    | 马超   | 2021-11-05 |   4000 |  3 |
| 研发部    | 黄忠   | 2021-11-06 |   4000 |  3 |
| 销售部    | 曹操   | 2021-11-01 |   2000 |  1 |
| 销售部    | 许褚   | 2021-11-02 |   3000 |  1 |
| 销售部    | 典韦   | 2021-11-03 |   5000 |  2 |
| 销售部    | 张辽   | 2021-11-04 |   6000 |  2 |
| 销售部    | 徐晃   | 2021-11-05 |   9000 |  3 |
| 销售部    | 曹洪   | 2021-11-06 |   6000 |  3 |
+-----------+--------+------------+--------+----+
12 rows in set (0.00 sec)


```

## 聚合类窗口函数



### max

### min


### count



### sum

```sql
[root@127.0.0.1:8032 16:16:21(db1)]$ select dname,ename,salary from employee;
+-----------+--------+--------+
| dname     | ename  | salary |
+-----------+--------+--------+
| 研发部    | 刘备   |   3000 |
| 研发部    | 关羽   |   5000 |
| 研发部    | 张飞   |   7000 |
| 研发部    | 赵云   |   7000 |
| 研发部    | 马超   |   4000 |
| 研发部    | 黄忠   |   4000 |
| 销售部    | 曹操   |   2000 |
| 销售部    | 许褚   |   3000 |
| 销售部    | 典韦   |   5000 |
| 销售部    | 张辽   |   6000 |
| 销售部    | 徐晃   |   9000 |
| 销售部    | 曹洪   |   6000 |
+-----------+--------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 16:16:39(db1)]$ select dname,ename,salary,sum(salary) over(partition by dname order by salary  rows between 2 preceding and current row) as sum_salary from employee;
+-----------+--------+--------+------------+
| dname     | ename  | salary | sum_salary |
+-----------+--------+--------+------------+
| 研发部    | 刘备   |   3000 |       3000 |
| 研发部    | 马超   |   4000 |       7000 |
| 研发部    | 黄忠   |   4000 |      11000 |
| 研发部    | 关羽   |   5000 |      13000 |
| 研发部    | 张飞   |   7000 |      16000 |
| 研发部    | 赵云   |   7000 |      19000 |
| 销售部    | 曹操   |   2000 |       2000 |
| 销售部    | 许褚   |   3000 |       5000 |
| 销售部    | 典韦   |   5000 |      10000 |
| 销售部    | 张辽   |   6000 |      14000 |
| 销售部    | 曹洪   |   6000 |      17000 |
| 销售部    | 徐晃   |   9000 |      21000 |
+-----------+--------+--------+------------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 16:17:04(db1)]$ select dname,ename,salary,sum(salary) over(partition by dname order by salary) as sum_salary from employee;
+-----------+--------+--------+------------+
| dname     | ename  | salary | sum_salary |
+-----------+--------+--------+------------+
| 研发部    | 刘备   |   3000 |       3000 |
| 研发部    | 马超   |   4000 |      11000 |
| 研发部    | 黄忠   |   4000 |      11000 |
| 研发部    | 关羽   |   5000 |      16000 |
| 研发部    | 张飞   |   7000 |      30000 |
| 研发部    | 赵云   |   7000 |      30000 |
| 销售部    | 曹操   |   2000 |       2000 |
| 销售部    | 许褚   |   3000 |       5000 |
| 销售部    | 典韦   |   5000 |      10000 |
| 销售部    | 张辽   |   6000 |      22000 |
| 销售部    | 曹洪   |   6000 |      22000 |
| 销售部    | 徐晃   |   9000 |      31000 |
+-----------+--------+--------+------------+
12 rows in set (0.00 sec)


```

#### 测试窗口范围

```sql
[root@127.0.0.1:8032 09:23:06(db1)]$ select dname,ename,salary from employee;
+-----------+--------+--------+
| dname     | ename  | salary |
+-----------+--------+--------+
| 研发部    | 刘备   |   3000 |
| 研发部    | 关羽   |   5000 |
| 研发部    | 张飞   |   7000 |
| 研发部    | 赵云   |   7000 |
| 研发部    | 马超   |   4000 |
| 研发部    | 黄忠   |   4000 |
| 销售部    | 曹操   |   2000 |
| 销售部    | 许褚   |   3000 |
| 销售部    | 典韦   |   5000 |
| 销售部    | 张辽   |   6000 |
| 销售部    | 徐晃   |   9000 |
| 销售部    | 曹洪   |   6000 |
+-----------+--------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 09:23:09(db1)]$ select dname,ename,salary,sum(salary) over (partition by dname order by salary rows between 0 preceding and current row) as sum_salary from employee;
+-----------+--------+--------+------------+
| dname     | ename  | salary | sum_salary |
+-----------+--------+--------+------------+
| 研发部    | 刘备   |   3000 |       3000 |
| 研发部    | 马超   |   4000 |       4000 |
| 研发部    | 黄忠   |   4000 |       4000 |
| 研发部    | 关羽   |   5000 |       5000 |
| 研发部    | 张飞   |   7000 |       7000 |
| 研发部    | 赵云   |   7000 |       7000 |
| 销售部    | 曹操   |   2000 |       2000 |
| 销售部    | 许褚   |   3000 |       3000 |
| 销售部    | 典韦   |   5000 |       5000 |
| 销售部    | 张辽   |   6000 |       6000 |
| 销售部    | 曹洪   |   6000 |       6000 |
| 销售部    | 徐晃   |   9000 |       9000 |
+-----------+--------+--------+------------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 09:23:13(db1)]$ select dname,ename,salary,sum(salary) over (partition by dname order by salary rows between 1 preceding and current row) as sum_salary from employee;
+-----------+--------+--------+------------+
| dname     | ename  | salary | sum_salary |
+-----------+--------+--------+------------+
| 研发部    | 刘备   |   3000 |       3000 |
| 研发部    | 马超   |   4000 |       7000 |
| 研发部    | 黄忠   |   4000 |       8000 |
| 研发部    | 关羽   |   5000 |       9000 |
| 研发部    | 张飞   |   7000 |      12000 |
| 研发部    | 赵云   |   7000 |      14000 |
| 销售部    | 曹操   |   2000 |       2000 |
| 销售部    | 许褚   |   3000 |       5000 |
| 销售部    | 典韦   |   5000 |       8000 |
| 销售部    | 张辽   |   6000 |      11000 |
| 销售部    | 曹洪   |   6000 |      12000 |
| 销售部    | 徐晃   |   9000 |      15000 |
+-----------+--------+--------+------------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 09:23:20(db1)]$ select dname,ename,salary,sum(salary) over (partition by dname order by salary rows between 2 preceding and current row) as sum_salary from employee;
+-----------+--------+--------+------------+
| dname     | ename  | salary | sum_salary |
+-----------+--------+--------+------------+
| 研发部    | 刘备   |   3000 |       3000 |
| 研发部    | 马超   |   4000 |       7000 |
| 研发部    | 黄忠   |   4000 |      11000 |
| 研发部    | 关羽   |   5000 |      13000 |
| 研发部    | 张飞   |   7000 |      16000 |
| 研发部    | 赵云   |   7000 |      19000 |
| 销售部    | 曹操   |   2000 |       2000 |
| 销售部    | 许褚   |   3000 |       5000 |
| 销售部    | 典韦   |   5000 |      10000 |
| 销售部    | 张辽   |   6000 |      14000 |
| 销售部    | 曹洪   |   6000 |      17000 |
| 销售部    | 徐晃   |   9000 |      21000 |
+-----------+--------+--------+------------+
12 rows in set (0.00 sec)

```


#### unbounded preceding


```sql
[root@127.0.0.1:8032 09:23:47(db1)]$ select dname,ename,salary from employee;
+-----------+--------+--------+
| dname     | ename  | salary |
+-----------+--------+--------+
| 研发部    | 刘备   |   3000 |
| 研发部    | 关羽   |   5000 |
| 研发部    | 张飞   |   7000 |
| 研发部    | 赵云   |   7000 |
| 研发部    | 马超   |   4000 |
| 研发部    | 黄忠   |   4000 |
| 销售部    | 曹操   |   2000 |
| 销售部    | 许褚   |   3000 |
| 销售部    | 典韦   |   5000 |
| 销售部    | 张辽   |   6000 |
| 销售部    | 徐晃   |   9000 |
| 销售部    | 曹洪   |   6000 |
+-----------+--------+--------+
12 rows in set (0.00 sec)

[root@127.0.0.1:8032 09:25:59(db1)]$ select dname,ename,salary,sum(salary) over (partition by dname order by salary rows between unbounded preceding and current row) as sum_salary from employee;
+-----------+--------+--------+------------+
| dname     | ename  | salary | sum_salary |
+-----------+--------+--------+------------+
| 研发部    | 刘备   |   3000 |       3000 |
| 研发部    | 马超   |   4000 |       7000 |
| 研发部    | 黄忠   |   4000 |      11000 |
| 研发部    | 关羽   |   5000 |      16000 |
| 研发部    | 张飞   |   7000 |      23000 |
| 研发部    | 赵云   |   7000 |      30000 |
| 销售部    | 曹操   |   2000 |       2000 |
| 销售部    | 许褚   |   3000 |       5000 |
| 销售部    | 典韦   |   5000 |      10000 |
| 销售部    | 张辽   |   6000 |      16000 |
| 销售部    | 曹洪   |   6000 |      22000 |
| 销售部    | 徐晃   |   9000 |      31000 |
+-----------+--------+--------+------------+
12 rows in set (0.00 sec)

```




### avg


### group_concat








